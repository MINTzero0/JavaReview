1. 编译阶段发生的事情
编译阶段就像是“课前准备”，它的任务是检查代码的正确性，确保语法没问题，并生成字节码文件（.class）。具体来说，编译阶段会发生以下几件事：

1.1 语法检查
变量声明和类型检查：编译器会检查你声明的变量类型是否正确，确保变量已经声明过。

比如：

int x = 10;  // 编译阶段，编译器检查变量x是否声明过，类型是否匹配
String name = "葵";  // 编译时检查变量name的类型是String
语法正确的话，编译器会生成字节码文件 .class，如果有错误（比如类型不匹配），编译会失败。
1.2 访问权限检查
编译器会检查你是否有权限访问类的成员，是否符合访问修饰符的规则。

比如：

class A {
    private int count;
    public void method() {
        System.out.println(count);
    }
}

A a = new A();
System.out.println(a.count);  // 编译时错误，无法访问private变量
a.count 访问时编译器会发现 count 是 private，不能在 A 类外部访问，因此会报错。
1.3 方法和变量的静态绑定（编译时多态）
如果访问一个方法或变量，编译器会根据声明类型来决定你可以访问哪些成员。静态方法调用和成员变量访问发生在编译阶段。

比如：

A a = new B();
a.count = 10;  // 编译时，访问的是A中的count（无论a指向B）
编译时，a 的类型是 A，因此 count 只能访问 A 中的 count，而不是 B 中的 count。
1.4 静态方法调用
静态方法（使用 static 关键字的方法）在编译时就已经确定调用对象了，不会因为实例对象的类型变化而改变调用。

比如：

class MyClass {
    public static void staticMethod() {
        System.out.println("Static Method");
    }
}
MyClass.staticMethod();  // 直接编译通过
这个方法在编译阶段就已经确定，它是属于 MyClass 的，无论你在什么地方调用，都知道调用的是 MyClass 的静态方法。
2. 运行阶段发生的事情
运行阶段就像是“考试的时候”，它是程序实际运行时发生的事情。运行时会根据对象的实际类型来决定具体的行为。下面是运行阶段的几个关键特性：

2.1 动态方法绑定（运行时多态）
在运行时，JVM会根据实际对象的类型来决定调用哪个版本的方法。这种方法的选择是在程序运行时决定的，而不是编译时。

比如：

A a = new B();
a.method();  // 运行时，a指向B的实例，因此调用B的method()
运行时会发现，a 实际指向的是 B 类型的对象，所以会调用 B 中的 method() 方法，而不是 A 中的 method()。
2.2 构造函数
构造函数的调用也是发生在运行阶段，虽然构造函数在编译时会检查是否匹配，但真正的实例化和调用时，JVM会根据实际情况决定调用哪个构造函数。

比如：

class A {
    A() {
        System.out.println("A's constructor");
    }
}

class B extends A {
    B() {
        System.out.println("B's constructor");
    }
}

public class Test {
    public static void main(String[] args) {
        A a = new B();  // 运行时，先调用B的构造函数，再调用A的构造函数
    }
}
这里，new B() 时，运行时JVM会先调用 B 的构造函数，然后调用 A 的构造函数。
2.3 对象的实际类型
运行时，JVM会根据对象的实际类型来决定要执行的代码。比如，a 是 A 类型的引用，但是可能指向 B 类型的对象，那么就会执行 B 类的方法。

比如：

A a = new B();
System.out.println(a instanceof B);  // 运行时，输出 true，因为a实际指向B
这个 instanceof 判断是在运行时才会根据对象的实际类型决定。
2.4 动态代理和反射
使用 Java 的反射或动态代理机制时，相关的操作也是在运行时决定的。比如动态生成代理类或者调用反射方法，编译器并不会预知这些操作，必须等到程序运行时。

比如：

Method method = MyClass.class.getMethod("myMethod");
method.invoke(myObject);  // 运行时通过反射来调用方法
总结：编译阶段 VS 运行阶段
编译阶段：
语法检查、类型检查。
静态绑定：方法调用和成员变量的访问是通过编译时的类型决定的。
静态方法和构造函数。
运行阶段：
动态绑定：方法调用（如多态）和对象的实际类型。
运行时决定调用哪个构造函数、实例化对象。
动态代理、反射等操作。
形象化比喻
可以把编译和运行比作制作食谱和做菜：

编译阶段： 就是制定食谱的时候，你决定了做什么菜（变量、方法），但是并没有开始做菜。这个过程你检查了材料和步骤（类型检查、方法绑定等），确保不会出错。

运行阶段： 你实际开始做菜了，根据手头的材料来决定做什么菜（对象的实际类型决定调用哪个方法）。比如，食谱上写着“用鸡肉做菜”，但实际你手上有牛肉，那就根据实际情况做不同的菜。